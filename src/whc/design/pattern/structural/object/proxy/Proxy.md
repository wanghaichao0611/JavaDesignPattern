# 代理模式

## 1.定义

代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制原对象的访问

## 2.类图

![img.png](img/ProxyThought.png)

1. Subject(抽象主题角色)：它声明了真实主题和代理主题的公共接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程
2. Proxy(代理主题角色)
   ：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理角色中提供了一个与真实主题角色的相同接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实对象的使用加以约束。通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用其真实主题对象中的操作。
3. RealSubject(真实主题角色)：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作

## 3.分类

1. 远程代理(Remote Proxy)：为一个位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador)
2. 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗较小的对象来表示，真实对象只在需要时才会被真正创建
3. 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限
4. 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果
5. 智能引用代理(Smart Reference Proxy)；当一个对象被引用时提供一些额外的操作，例如讲被调用的次数记录下来

## 4.代理模式应用示例

> > 某软件公司承接了某信息咨询公司得收费商务信息查询系统的开发任务，该系统的基本需求如下：

1. 在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统
2. 在进行商务信息查询时系统需要记录查询日志，以边根据查询次数收费查询费用

该软件公司的开发人员已完成了商务信息查询模块开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日记记录功能，客户端代码可以无区别地对待原始的
商务信息模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新功能，使用代理模式进行设计并实现

![img.png](img/ProtectAndSmart.png)

## 5.Java动态代理

动态代理(Dynamic Proxy)可以让系统在运行运行时根据实际需要来动态代理创建代理类，让同一个代理类能够代理多个不同的主题类而且可以代理不同的方法。动态代理是一种较为高级的代理模式，它在事务管理，AOP领域都发挥了作用

### 5.1 Proxy类

1. public static Class <?> getProxyClass(ClassLoader loader,Class<?>... interface):
   该方法用于返回一个Class类型的代理类，在参数中需要提供加载器并需要指定代理的接口数据(与真实主题类的接口列表一致)
2. public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h):
   该方法返回一个动态创建的代理类的实例，方法中第一个参数的loader表示代理类的类加载器，第二个参数interfaces表示代理类所实现的接口列表(与真实主题类的接口列表一致)，第三个参数是h表示所指派的调用处理程序类

### 5.2 InvocationHandler接口

InvocationHandler接口是处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供给一个相关的具体调用处理者(InvocationHandler h)。在接口中声明了以下方法：

1. public Object invoke(Object proxy,Method method,Object[] args)
2. 第一个参数代理实例中的业务方法被调用时将自动调用该方法。invoke方法包含三个参数，其中第一个参数proxy表示代理类的实例，第二个参数method表示需要代理的方法，带三个参数args表示代理方法的参数数组
3. 动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时调用请求会将请求自动转发给InvocationHandler对象的invoke()方法，由invoke()方法来实现对请求的统一处理

### 5.3 JDK动态代理示例jdkProxy包

> > 某软件公司要为公司的OA系统数据访问层DAO增加方法调用日志，记录每一个方法调用的时间和调用结果，现使用动态代理进行设计和实现

## 6.1 代理模式优点

1. 能够协调调用者和被调用者，在一定程序上降低了系统的耦合度
2. 客户端可以针对抽象主题角色进行编程，增加和更换代理类的无需修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性
3. 远程代理为位于两个不同地址空间的对象的访问提供了一种实现机制，可以讲一些消耗资源较多的对象和操作移植性能更好的计算机上，提供了系统的整体运行效率
4. 虚拟代理通过一个消耗资源较少的对象代表一个消耗资源过多的对象，可以在一定程度上节省系统的运行时间
5. 缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间
6. 保护代理可以控制对一个对象的访问权限，为不同用户不同级别的使用权限

## 6.2 代理模式缺点

1. 由于客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理
2. 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理

## 6.3 代理模式适用环境

1. 当客户端对象需要访问远程主机中的对象可以使用远程代理
2. 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销。缩短运行时间可以使用虚拟代理，例如一个对象需要很长时间才可以完成加载时间。
3. 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以共多个客户端共享访问这些结果时可以用缓冲代理。通过缓存代理，系统无需在客户端每一个访问时都重新执行操作，只需直接从缓冲区获取操作结果即可
4. 当需要控制对一个对象访问提供不同的访问权限时，可以使用保护代理
5. 当需要为一个对象的访问(引用)提供一些额外的操作时可以使用智能引用代理


